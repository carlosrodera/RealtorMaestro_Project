Realtor360: Plan Maestro Final de Desarrollo en Replit
1. Visión General del Proyecto y Rol del Tech Lead en Replit
Realtor360 será una plataforma web de vanguardia, desarrollada en Replit, que revolucionará el marketing inmobiliario para profesionales en España. Permitirá la transformación de imágenes de propiedades mediante IA y la generación de descripciones persuasivas. Como Tech Lead, tu misión es dirigir la implementación técnica de esta visión, asegurando una arquitectura robusta, escalable, una experiencia de usuario excepcional y aprovechando al máximo las capacidades del ecosistema Replit.
2. Objetivos Clave del Desarrollo en Replit
Implementar la totalidad de las funcionalidades de Realtor360 (transformación de imágenes y generación de descripciones) con un enfoque en la calidad y la experiencia de usuario.
Utilizar Replit como IDE principal, plataforma de colaboración, y sistema de despliegue para entornos de desarrollo, staging y producción.
Construir sobre una arquitectura proactiva de escalabilidad, integrando Supabase Edge Functions y n8n para procesamiento distribuido.
Implementar una estrategia multicapa para proveedores de IA, conmutación por error y optimización de costos.
Desarrollar un sistema de caché inteligente y telemetría avanzada.
Configurar workflows eficientes en .replit y CI/CD con GitHub Actions.
Gestionar la configuración y secretos de forma segura mediante Replit Secrets.
3. Stack Tecnológico Optimizado (Consolidado)
Frontend (Replit client/):
Framework: React 18 con TypeScript 5
Gestión de Estado: Zustand (con middleware persist)
Formularios: React Hook Form + Zod (validación)
Componentes UI: Sistema personalizado basado en shadcn/ui (Radix UI)
Editor de Imágenes: Fabric.js (para Canvas avanzado)
Estilización: Tailwind CSS (con sistema de design tokens)
Backend (Supabase & n8n):
Base de Datos y Autenticación: Supabase (PostgreSQL, Auth, Storage, Realtime)
APIs y Lógica de Negocio: Supabase Edge Functions (TypeScript/Deno)
Orquestación de Workflows IA: n8n (auto-hospedado o cloud, integrado vía webhooks)
Proveedores IA: Estrategia multi-proveedor (adaptadores para diferentes servicios)
DevOps & Infraestructura (Gestionado en/desde Replit):
Entorno de Desarrollo: Replit Workspace
CI/CD: GitHub Actions desplegando a Replit
Entornos: Desarrollo (Replit Dev), Staging (Replit Hosted), Producción (Replit Hosted - Plan de pago)
Monitorización: Sentry (errores), LogRocket (opcional, para sesiones), Métricas de Supabase, Uptime Robot. Implementación de telemetría avanzada con Winston para logs estructurados y envío a servicio externo si es necesario.
Performance: Web Vitals, Lighthouse (integrado en CI y localmente).
Infraestructura como Código (IaC) - Opcional Avanzado:
Terraform (para gestionar recursos de Supabase o servicios externos si la complejidad crece más allá de la gestión manual/UI). Inicialmente, la UI de Supabase y Replit será suficiente.
4. Arquitectura del Proyecto en Replit
Proponemos una estructura de monorepo dentro del Workspace de Replit:
Realtor360/
├── client/                      # Aplicación Frontend React/TypeScript (shadcn/ui, Zustand, Fabric.js)
│   ├── public/
│   ├── src/
│   │   ├── app/                 # Rutas y layouts (Next.js App Router style o similar)
│   │   ├── components/
│   │   │   ├── common/
│   │   │   ├── editor/          # Componentes para Fabric.js Canvas
│   │   │   ├── description/     # Componentes para generación de descripciones
│   │   │   └── ui/              # Primitivas de shadcn/ui
│   │   ├── features/            # Lógica de negocio específica de características
│   │   ├── hooks/
│   │   ├── lib/                 # Utilidades, adaptadores IA, cliente Supabase
│   │   ├── services/            # Lógica para llamar a Supabase Edge Functions / n8n
│   │   ├── store/               # Stores de Zustand
│   │   └── types/
│   ├── package.json
│   └── tsconfig.json
├── supabase/                    # Configuración de Supabase
│   ├── migrations/              # Migraciones SQL (gestionadas por Supabase CLI)
│   ├── functions/               # Supabase Edge Functions (TypeScript)
│   │   ├── auth/
│   │   ├── projects/
│   │   ├── transformations/
│   │   ├── descriptions/
│   │   └── webhooks/            # Ej: Stripe webhooks
│   └── seed.sql                 # Datos iniciales
├── n8n/                         # Definiciones de Workflows n8n (JSON/YAML)
│   ├── image-transformation-v1.json
│   ├── description-generation-v1.json
│   └── subflows/
├── docs/                        # Documentación técnica, decisiones de arquitectura
├── .replit                      # Configuración de Workflows de Replit
├── replit.nix                   # Configuración del entorno Nix de Replit
├── package.json                 # Raíz para scripts generales (lint, test, workspaces)
└── tsconfig.base.json
Use code with caution.
5. Configuración del Entorno Replit
Workspace Principal: "Realtor360" en Replit.
replit.nix:
{ pkgs }: {
  deps = [
    pkgs.nodejs_18 # O la LTS más reciente
    pkgs.nodePackages.typescript
    pkgs.nodePackages.pnpm # O npm/yarn
    # pkgs.supabase-cli # Si se gestiona directamente en Replit
  ];
}
Use code with caution.
Nix
Replit Secrets:
SUPABASE_URL, SUPABASE_ANON_KEY, SUPABASE_SERVICE_ROLE_KEY
N8N_WEBHOOK_URL_IMAGE_TRANSFORM, N8N_WEBHOOK_URL_DESC_GEN
N8N_API_KEY (si la instancia n8n está protegida)
STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET
PRIMARY_AI_PROVIDER_API_KEY, FALLBACK_AI_PROVIDER_API_KEY_1, ...
SENTRY_DSN
REDIS_URL (si se implementa caché distribuida externa)
JWT_SECRET (si se usa para algo fuera de Supabase Auth)
6. Esquema de Base de Datos (Supabase - Combinando lo mejor de ambos informes)
-- Perfiles de Usuario (extendiendo auth.users)
CREATE TABLE public.profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  full_name TEXT,
  company TEXT,
  avatar_url TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Productos de Suscripción (Categorías generales de planes)
CREATE TABLE public.subscription_products (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  code TEXT NOT NULL UNIQUE, -- ej: 'core_services', 'premium_features'
  description TEXT,
  is_active BOOLEAN DEFAULT true,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Planes de Suscripción (Ofertas específicas)
CREATE TABLE public.subscription_plans (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  product_id UUID NOT NULL REFERENCES public.subscription_products(id),
  name TEXT NOT NULL, -- ej: 'Professional Monthly', 'Agency Yearly'
  code TEXT NOT NULL, -- ej: 'pro_monthly', 'agency_yearly'
  interval TEXT NOT NULL CHECK (interval IN ('month', 'year')), -- Stripe usa 'month', 'year'
  amount_cents INTEGER NOT NULL, -- Precio en céntimos
  currency TEXT NOT NULL DEFAULT 'eur',
  features JSONB NOT NULL, -- { "image_transforms_limit": 30, "description_gens_limit": 15, "hd_resolution": true }
  is_active BOOLEAN DEFAULT true,
  trial_period_days INTEGER DEFAULT 0,
  stripe_price_id TEXT UNIQUE, -- ID del precio en Stripe
  UNIQUE(product_id, code, interval),
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Addons de Suscripción (Opcionales)
CREATE TABLE public.subscription_addons (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL,
  code TEXT NOT NULL UNIQUE, -- ej: 'extra_10_transforms', 'priority_support'
  description TEXT,
  amount_cents INTEGER NOT NULL,
  currency TEXT NOT NULL DEFAULT 'eur',
  quota_impact JSONB, -- { "image_transforms_boost": 10 }
  is_active BOOLEAN DEFAULT true,
  stripe_price_id TEXT UNIQUE, -- ID del precio en Stripe
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Suscripciones de Usuario
CREATE TABLE public.user_subscriptions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(), -- ID de la suscripción en nuestra DB
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  plan_id UUID NOT NULL REFERENCES public.subscription_plans(id),
  status TEXT NOT NULL CHECK (status IN ('trialing', 'active', 'past_due', 'canceled', 'unpaid', 'paused')), -- Alineado con Stripe
  current_period_start TIMESTAMP WITH TIME ZONE NOT NULL,
  current_period_end TIMESTAMP WITH TIME ZONE NOT NULL,
  cancel_at_period_end BOOLEAN DEFAULT false,
  canceled_at TIMESTAMP WITH TIME ZONE,
  trial_start TIMESTAMP WITH TIME ZONE,
  trial_end TIMESTAMP WITH TIME ZONE,
  metadata JSONB,
  stripe_subscription_id TEXT UNIQUE, -- ID de la suscripción en Stripe
  stripe_customer_id TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Addons de Suscripción Activos para un Usuario
CREATE TABLE public.user_subscription_addons (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_subscription_id UUID NOT NULL REFERENCES public.user_subscriptions(id) ON DELETE CASCADE,
  addon_id UUID NOT NULL REFERENCES public.subscription_addons(id),
  quantity INTEGER NOT NULL DEFAULT 1,
  stripe_subscription_item_id TEXT UNIQUE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Cuotas de Uso del Usuario (Reseteables)
CREATE TABLE public.user_usage_quotas (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  resource_type TEXT NOT NULL, -- 'image_transformations', 'description_generations'
  used_count INTEGER NOT NULL DEFAULT 0,
  limit_count INTEGER NOT NULL,
  period_start_at TIMESTAMP WITH TIME ZONE NOT NULL,
  period_end_at TIMESTAMP WITH TIME ZONE NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(user_id, resource_type, period_start_at) -- Asegura una entrada por recurso por periodo
);

-- Proyectos (Agrupan transformaciones y descripciones)
CREATE TABLE public.projects (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  description TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Transformaciones de Imágenes
CREATE TABLE public.transformations (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  project_id UUID REFERENCES public.projects(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES public.profiles(id),
  original_image_path TEXT NOT NULL, -- Path en Supabase Storage
  transformed_image_path TEXT,   -- Path en Supabase Storage
  annotations JSONB,             -- Datos de Fabric.js
  style TEXT NOT NULL,           -- ej: 'moderno', 'minimalista'
  custom_prompt TEXT,
  ai_provider_used TEXT,
  processing_time_ms INTEGER,
  status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'completed', 'failed')),
  error_message TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Descripciones Generadas
CREATE TABLE public.descriptions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  project_id UUID REFERENCES public.projects(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES public.profiles(id),
  property_data JSONB NOT NULL,  -- Datos del formulario
  source_image_paths TEXT[],     -- Paths de imágenes usadas como input
  generated_text TEXT,
  tone TEXT NOT NULL,
  length_option TEXT NOT NULL, -- ej: 'corta', 'media', 'larga'
  language TEXT NOT NULL DEFAULT 'es',
  ai_provider_used TEXT,
  processing_time_ms INTEGER,
  status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'completed', 'failed')),
  error_message TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Logs de Uso (Para auditoría y analytics detallados)
CREATE TABLE public.usage_logs (
  id BIGSERIAL PRIMARY KEY,
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
  action_type TEXT NOT NULL, -- 'image_transform_success', 'desc_gen_failed', 'login'
  resource_id UUID,          -- ID de la transformación, descripción, etc.
  resource_type TEXT,
  metadata JSONB,            -- Datos adicionales sobre la acción
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Triggers para updated_at
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Aplicar el trigger a tablas relevantes:
CREATE TRIGGER set_profiles_updated_at BEFORE UPDATE ON public.profiles FOR EACH ROW EXECUTE FUNCTION public.handle_updated_at();
CREATE TRIGGER set_user_subscriptions_updated_at BEFORE UPDATE ON public.user_subscriptions FOR EACH ROW EXECUTE FUNCTION public.handle_updated_at();
-- ... y para projects, transformations, descriptions, user_usage_quotas.

-- Función para crear perfil automáticamente y asignar plan gratuito inicial (si aplica)
CREATE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
DECLARE
  free_plan_id UUID;
  new_profile_id UUID;
BEGIN
  -- Crear perfil
  INSERT INTO public.profiles (id, full_name, avatar_url)
  VALUES (NEW.id, NEW.raw_user_meta_data->>'full_name', NEW.raw_user_meta_data->>'avatar_url')
  RETURNING id INTO new_profile_id;

  -- Encontrar el plan gratuito
  SELECT id INTO free_plan_id FROM public.subscription_plans WHERE code = 'free_tier_monthly' AND is_active = true LIMIT 1; -- Asume un plan con este código

  -- Si existe un plan gratuito, crear una suscripción y cuotas iniciales
  IF free_plan_id IS NOT NULL THEN
    INSERT INTO public.user_subscriptions (user_id, plan_id, status, current_period_start, current_period_end, stripe_customer_id)
    VALUES (new_profile_id, free_plan_id, 'active', NOW(), NOW() + INTERVAL '100 year', NEW.raw_user_meta_data->>'stripe_customer_id'); -- Período muy largo para "gratis para siempre"

    -- Ejemplo de cuotas para plan gratuito (debería obtenerse de plan.features)
    INSERT INTO public.user_usage_quotas (user_id, resource_type, used_count, limit_count, period_start_at, period_end_at)
    VALUES
      (new_profile_id, 'image_transformations', 0, 3, NOW(), NOW() + INTERVAL '1 month'),
      (new_profile_id, 'description_generations', 0, 1, NOW(), NOW() + INTERVAL '1 month');
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW
EXECUTE FUNCTION public.handle_new_user();
Use code with caution.
SQL
Nota: Se asume RLS (Row Level Security) configurado en Supabase para todas las tablas sensibles.
7. Estrategia Multicapa de Proveedores IA (Implementación en n8n/Supabase Edge Functions)
Adaptadores: En client/lib/ai-adapters/ o supabase/functions/_shared/ai-adapters/, crear clases/funciones adaptadoras para cada proveedor IA (OpenAI, Stability AI, Replicate, etc.).
// Ejemplo: supabase/functions/_shared/ai-adapters/base-adapter.ts
export interface AIProviderAdapter {
  name: string;
  transformImage(params: ImageTransformParams): Promise<ImageTransformResult>;
  generateDescription(params: DescriptionGenParams): Promise<DescriptionGenResult>;
}
Use code with caution.
TypeScript
Servicio de Orquestación (Supabase Edge Function):
Una Edge Function (supabase/functions/ai-orchestrator/index.ts) que implemente la lógica de ImageTransformationService y DescriptionGenerationService.
Recibirá la solicitud, aplicará la lógica de selección de proveedor (basada en estilo, calidad, coste, disponibilidad de cuotas almacenadas en user_usage_quotas o subscription_plans.features), llamará al adaptador correspondiente, y gestionará fallos y reintentos con proveedores de fallback.
n8n como Ejecutor de Tareas Pesadas: La Edge Function puede invocar un webhook de n8n para el procesamiento real si es muy largo o complejo, pasando el proveedor seleccionado y los parámetros. n8n luego llama a la API del proveedor IA.
Prompt de ejemplo para IA (para desarrollador construyendo la función):
"Contexto: Necesito una Supabase Edge Function en TypeScript llamada 'ai-orchestrator' para gestionar transformaciones de imágenes. Acción: Implementar una lógica que reciba 'style', 'userId', 'imageData'. Especificaciones: Consultar 'user_usage_quotas' y 'subscription_plans' para determinar el nivel de calidad. Seleccionar dinámicamente un proveedor IA de una lista (ProviderA, ProviderB) basado en el estilo y la calidad. Implementar un reintento con un proveedor de fallback si el primario falla. Registrar la decisión y el resultado. Usar Deno y el cliente Supabase. Restricciones: No llamar directamente a las APIs de IA, usar módulos adaptadores (paths a ser definidos)."
8. Arquitectura de Caché Inteligente (Adaptado a Replit/Supabase)
Nivel 1: Caché del Navegador: Para activos estáticos (gestionado por Replit/CDN) y datos de sesión/UI.
Nivel 2: Caché de Supabase Edge Functions: Usar Deno Cache API para respuestas comunes de Edge Functions (ej. lista de estilos, datos de perfil no críticos).
Nivel 3: Caché de Resultados de IA (Supabase Storage + Tabla de Metadatos):
Para transformaciones idénticas (misma imagen original + mismas anotaciones + mismo estilo), almacenar el resultado en Supabase Storage y una referencia en una tabla cached_transformations (hash_input, output_path, created_at, last_accessed_at, access_count).
TTL gestionado por un cron job de Supabase (pg_cron) que limpia entradas antiguas o menos accedidas.
Nivel 4: Redis (Opcional Externo): Si la carga es muy alta, un Redis externo (conectado vía Replit Secrets) para caché de resultados de IA o datos frecuentemente accedidos. La "predicción" puede ser una simplificación basada en access_count y last_accessed_at.
9. Telemetría Avanzada (Implementación)
Logs Estructurados: Winston (como en el ejemplo inicial), configurado en Supabase Edge Functions y en el backend de Replit (si existe). Enviar a un servicio de logging externo si la retención/búsqueda de Replit no es suficiente.
// Ejemplo en una Supabase Edge Function: supabase/functions/_shared/logger.ts
// (Simplificado, Winston puede ser pesado para Edge Functions; considerar un logger más ligero o console.json)
// Para Edge Functions, un simple console.log(JSON.stringify({level, message, ...metadata})) puede ser suficiente.
Use code with caution.
JavaScript
Métricas (Histogramas, Gauges):
Si Sentry no cubre, se puede enviar a Prometheus/Grafana Cloud o similar usando un cliente ligero desde Edge Functions o n8n.
Ejemplo: ai_response_time_ms{provider="OpenAI", type="image_transform"}.
Seguimiento de Eventos de Negocio: Registrar en usage_logs y/o enviar a una herramienta de analytics (PostHog, Mixpanel).
Experience Sampling: En el frontend, después de una transformación/descripción, solicitar feedback (1-5 estrellas, opcionalmente un comentario). Almacenar en una tabla user_feedback.
10. Plan de Desarrollo Iterativo con Checkpoints Estratégicos (13 Semanas en Replit)
Fase 1: Configuración Estratégica y Fundación (2 Semanas)
Semana 1: Configuración del Proyecto y Arquitectura Base
[Replit] Crear Workspace, configurar replit.nix, package.json raíz (con workspaces pnpm/yarn), linters (ESLint, Prettier), Husky.
[Replit] Configurar Replit Secrets iniciales (Supabase dev).
[Supabase] Setup de proyectos Supabase (dev, staging). Migración inicial para profiles.
[Frontend] Estructura básica React+TS, TailwindCSS, shadcn/ui. Layout principal.
[CI/CD] Pipeline básico GitHub Actions para lint y build en PRs.
Tech Lead: Definir estándares de código, plantillas. Documentar patrones iniciales.
Prompt: "Contexto: Configurando un nuevo proyecto React 18 con TypeScript en Replit usando pnpm workspaces. Acción: Crear la estructura de directorios para 'client/' y configurartsconfig.jsonypackage.jsoniniciales para el cliente. Especificaciones: Incluir dependencias base (react, react-dom, typescript, tailwindcss, clsx, tailwind-merge). Habilitar rutas estrictas y chequeos de TS. Restricciones: No instalar librerías de UI complejas aún, solo la base."
Semana 2: Autenticación, UI Base y Telemetría Inicial
[Supabase] Implementar RLS básica para profiles. Función handle_new_user.
[Frontend] Implementar flujos de autenticación (Login, Registro, Recuperar Contraseña) con Supabase Auth y componentes shadcn/ui.
[Replit] Implementar Winston para logging estructurado básico en Supabase Edge Functions (o alternativa ligera).
[Monitorización] Configurar Sentry en frontend y para Edge Functions.
Entregable: App base con login/registro funcional, desplegada en Replit dev.
Fase 2: Transformación de Imágenes (3 Semanas)
Semana 3: Editor de Canvas Avanzado
[Frontend] Implementar Canvas con Fabric.js: carga de imagen, herramientas de anotación (pincel, borrador, formas básicas, texto), gestión de estado con Zustand. Guardado de anotaciones como JSON.
Tech Lead: Revisar rendimiento del Canvas, asegurar modularidad.
Semana 4: Orquestación IA y Procesamiento de Imágenes
[Supabase/n8n] Diseñar e implementar flujo n8n básico para transformación de imagen (webhook -> llamada a 1 proveedor IA -> guardar resultado).
[Supabase] Edge Function (transform-image-request) que reciba datos del frontend, valide, y dispare el webhook n8n. Actualizar tabla transformations (status: pending).
[Replit] Configurar N8N_WEBHOOK_URL_IMAGE_TRANSFORM en Secrets.
[Caché] Implementar caché de resultados Nivel 2 (Edge Function) para solicitudes idénticas recientes.
Semana 5: UI de Transformación Completa
[Frontend] UI para selección de estilos (con previews), prompt personalizado. Interfaz de comparación antes/después. Opciones de ajuste fino (simuladas si la IA no lo soporta aún). Exportar/compartir.
[Supabase/n8n] n8n workflow debe actualizar transformations con transformed_image_path y status: completed/failed.
[Frontend] Escuchar cambios en transformations (Supabase Realtime) o polling para mostrar resultados.
Fase 3: Generación de Descripciones (3 Semanas)
Semana 6: Formulario de Propiedades y Datos
[Frontend] PropertyForm.tsx con React Hook Form, Zod, subida múltiple de imágenes a Supabase Storage, selección de amenidades, autocompletado de ubicación.
[Supabase] Crear tabla descriptions.
Semana 7: Orquestación IA para Descripciones
[Supabase/n8n] Flujo n8n para generación de descripciones (webhook -> análisis de imágenes (si aplica) -> llamada a LLM -> guardar resultado).
[Supabase] Edge Function (generate-description-request) que reciba datos del form, dispare webhook n8n, actualice descriptions (status: pending).
[Estrategia IA] Implementar la lógica de selección de proveedor (simplificada inicialmente) en la Edge Function o n8n.
Semana 8: Editor y UI de Descripciones
[Frontend] Editor de texto para refinar descripción generada. Sugerencias básicas (longitud, palabras clave). Regeneración parcial (párrafos). Exportación.
Fase 4: Gestión de Usuarios y Suscripciones Avanzadas (3 Semanas)
Semana 9: Perfiles, Proyectos y Suscripciones (DB y API)
[Supabase] Implementar esquema completo de subscription_products, subscription_plans, user_subscriptions, user_usage_quotas y projects.
[Supabase] Edge Functions para gestionar suscripciones (crear checkout Stripe, manejar webhooks de Stripe para actualizar user_subscriptions y user_usage_quotas).
Tech Lead: Asegurar la correcta lógica de gestión de cuotas.
Semana 10: UI de Gestión de Suscripciones y Proyectos
[Frontend] UI para gestión de perfil, selección/cambio de planes, visualización de uso y facturas (links a Stripe).
[Frontend] UI para crear/gestionar projects.
Semana 11: Dashboard de Analytics IA y Optimización de Cuotas
[Frontend/Supabase] Dashboard básico para el usuario mostrando sus estadísticas de uso, calidad promedio de transformaciones (basado en su feedback).
[Supabase] Refinar lógica de user_usage_quotas y su interacción con user_subscriptions.
[Telemetría] Implementar métricas de negocio clave (ej. #transformaciones/plan).
Fase 5: Pruebas, Lanzamiento y Refinamiento (2 Semanas)
Semana 12: Pruebas Exhaustivas y Optimización de Rendimiento
[QA] Pruebas unitarias (Jest), integración (React Testing Library, Supabase local con supabase start), E2E (Playwright/Cypress).
[DevOps] Auditoría de rendimiento (Lighthouse CI en GitHub Actions), optimización de bundles, imágenes WebP.
[Replit] Pruebas de carga en entorno Staging de Replit.
Semana 13: Preparación Final y Lanzamiento Beta
[Docs] Finalizar documentación técnica y de usuario.
[Replit] Configurar entorno de Producción en Replit (plan de pago, dominios personalizados).
[DevOps] Configurar backups de Supabase. Despliegue a Producción (beta cerrada).
[Monitorización] Monitorización activa post-lanzamiento. Recopilar feedback.
11. Configuración de Workflows en .replit
# .replit
[languages.typescript]
pattern = "**/*.{ts,tsx}"

[languages.javascript]
pattern = "**/*.{js,jsx}"

[packager]
language = "nodejs"
  [packager.features]
  packageSearch = true
  guessImports = true
  enabledForHosting = true

[env]
# Variables públicas o no secretas. Replit Secrets para las demás.
# NODE_ENV se setea automáticamente por Replit (development/production)

[run]
# Comando por defecto al presionar "Run" en Replit
# Asume que usas pnpm workspaces y el cliente es el principal para dev
default = "pnpm --filter client dev"

[debugger]
support = true
  # Configurar para debug de Edge Functions si es necesario localmente,
  # o para un backend Node.js si se añade uno.

[deployment]
# Comando que Replit usa para "Hosted Repl" si no se usa CI/CD para sobreescribir.
# Podría ser el comando para servir una SPA estática o iniciar un servidor.
# Este será generalmente manejado por el workflow de GitHub Actions.
run = ["pnpm", "run", "start:prod"] # Asume un script start:prod en package.json raíz

[workflows]
  [workflows.production_deploy] # Ejecutado por GitHub Actions o manualmente para producción
  mode = "sequential"
  tasks = [
    { command = "echo 'Setting up Production Environment...'" },
    { command = "pnpm install --frozen-lockfile" }, # Instalar todas las dependencias del monorepo
    { command = "pnpm --filter client build" },       # Build del frontend
    # { command = "pnpm --filter server build" },     # Si hubiera un server Node.js separado
    # Supabase migrations y function deploys se manejan vía Supabase CLI / GitHub Actions
    { command = "echo 'Build complete. Replit will serve client/dist or run the specified command.'" }
    # El comando final de ejecución es el `[deployment].run` o el que especifique `replit/action-deploy`
  ]

  [workflows.dev_environment] # Para el entorno de desarrollo local en Replit
  mode = "parallel"
  tasks = [
    { command = "pnpm --filter client dev", name = "FrontendDevServer" },
    # { command = "supabase start", name = "SupabaseLocal" } # Si gestionas Supabase CLI desde Replit
    # { command = "n8n start --tunnel", name = "n8nLocal" } # Si corres n8n localmente
  ]
Use code with caution.
Text
Nota: El script start:prod en el package.json raíz podría ser serve -s client/dist -p $PORT o similar si es una SPA. Si tienes un backend en Replit, sería pnpm --filter server start.
12. CI/CD con GitHub Actions y Replit
Workflow (.github/workflows/deploy-replit.yml):
name: Deploy Realtor360 to Replit

on:
  push:
    branches:
      - main # Despliegue a producción
      - staging # Despliegue a staging

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup PNPM
        uses: pnpm/action-setup@v2
        with:
          version: 8 # o la versión que uses

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18' # Coincidir con replit.nix
          cache: 'pnpm'

      - name: Install Dependencies
        run: pnpm install --frozen-lockfile

      - name: Lint and Test
        run: |
          pnpm run lint --workspaces --if-present
          pnpm run test --workspaces --if-present -- --ci --watchAll=false

      - name: Build Application
        run: pnpm run build --workspaces --if-present # Construye client y server (si existe)

      - name: Deploy to Replit Staging
        if: github.ref == 'refs/heads/staging'
        uses: replit/action-deploy@v2
        with:
          deploymentName: realtor360-staging
          replId: ${{ secrets.REPL_ID_STAGING }}
          token: ${{ secrets.REPL_TOKEN }}
          # Opcional: especificar el comando de ejecución de Replit .replit workflow
          # workflow: "production_deploy" # Nombre del workflow en .replit
          # O un comando directo:
          # runCommand: "pnpm run start:prod"
        env: # Pasar secretos de GitHub al entorno de build de Replit (si es necesario)
          REPLIT_ENV_SUPABASE_URL: ${{ secrets.SUPABASE_URL_STAGING }}
          # ... otros secretos específicos de staging

      - name: Deploy to Replit Production
        if: github.ref == 'refs/heads/main'
        uses: replit/action-deploy@v2
        with:
          deploymentName: realtor360-production
          replId: ${{ secrets.REPL_ID_PRODUCTION }}
          token: ${{ secrets.REPL_TOKEN }}
          # workflow: "production_deploy"
        env:
          REPLIT_ENV_SUPABASE_URL: ${{ secrets.SUPABASE_URL_PRODUCTION }}
          # ... otros secretos específicos de producción

      # Despliegue de Supabase (Migraciones y Funciones)
      - name: Deploy Supabase Migrations & Functions
        if: success() # Solo si los pasos anteriores tuvieron éxito
        env:
          SUPABASE_ACCESS_TOKEN: ${{ secrets.SUPABASE_ACCESS_TOKEN }}
          SUPABASE_DB_PASSWORD: ${{ github.ref == 'refs/heads/main' && secrets.SUPABASE_DB_PASSWORD_PRODUCTION || secrets.SUPABASE_DB_PASSWORD_STAGING }}
          PROJECT_ID: ${{ github.ref == 'refs/heads/main' && secrets.SUPABASE_PROJECT_ID_PRODUCTION || secrets.SUPABASE_PROJECT_ID_STAGING }}
        run: |
          # npm install -g supabase-cli # o usar una action para supabase-cli
          # supabase link --project-ref $PROJECT_ID
          # supabase db push # Asegurarse que esto es seguro para producción
          # supabase functions deploy --project-ref $PROJECT_ID
          echo "Supabase deployment steps would go here using Supabase CLI"
          echo "Consider using Supabase GitHub Action: https://github.com/supabase/setup-cli"
Use code with caution.
Yaml
GitHub Secrets: REPL_ID_STAGING, REPL_ID_PRODUCTION, REPL_TOKEN, SUPABASE_ACCESS_TOKEN, SUPABASE_DB_PASSWORD_STAGING, SUPABASE_DB_PASSWORD_PRODUCTION, SUPABASE_PROJECT_ID_STAGING, SUPABASE_PROJECT_ID_PRODUCTION, y todos los secretos que Replit necesita para cada entorno.
13. Métricas de Éxito y KPIs Técnicos Clave
Performance Web (Lighthouse): FCP < 1.8s, LCP < 2.5s, TTI < 3.8s, CLS < 0.1. Score > 90.
Fiabilidad del Servicio: Uptime (App Replit, Supabase, n8n) > 99.9%. Tasa de error (Sentry) < 0.1%.
Eficiencia IA: Tiempo promedio transformación < 15s. Tiempo promedio generación descripción < 10s. Costo por operación IA optimizado.
Adopción y Retención: (Definidos por negocio, pero impactados por UX/rendimiento).
Calidad Percibida: Feedback de usuarios (objetivo >4/5 estrellas).
14. Lista de Verificación Diaria del Tech Lead (Adaptada)
PRs Pendientes: Revisión ágil (máx 24h). Fomentar revisiones cruzadas.
Monitorización (Sentry, Replit Logs, Supabase Logs): Incidentes críticos.
Workflows n8n: Latencia, tasas de error (si n8n tiene dashboard).
Despliegues CI/CD: Estado, estabilidad de staging/producción.
Progreso del Sprint/Fase: Stand-ups, desbloqueo de impedimentos.
Rendimiento de la App (Staging/Prod): Vistazo rápido a Web Vitals o dashboards.
Uso de Cuotas IA/Supabase: Prevenir sobrecostos.
15. Próximos Pasos Inmediatos
Aprobación del Plan Maestro Final.
Configuración Inicial (Semana 1, Tarea 1): Workspace Replit, repos GitHub, replit.nix, package.json workspaces, linters, CI/CD básico, Supabase projects.
Kick-off con el equipo: Presentar plan, asignar primeras tareas.
Establecer rituales de equipo: Stand-ups, demos, retrospectivas.